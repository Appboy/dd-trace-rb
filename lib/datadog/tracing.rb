module Datadog
  # Datadog APM tracing public API.
  #
  # The Datadog team ensures that public methods in this module
  # only receive backwards compatible changes, and breaking changes
  # will only occur in new major versions releases.
  # @public_api
  module Tracing
    class << self
      # (see Datadog::Tracer#trace)
      # @public_api
      def trace(name, continue_from: nil, **span_options, &block)
        tracer.trace(name, continue_from: continue_from, **span_options, &block)
      end

      # (see Datadog::Tracer#continue_trace!)
      # @public_api
      def continue_trace!(digest, &block)
        tracer.continue_trace!(digest, &block)
      end

      # The currently active {Datadog::Tracer} instance.
      #
      # The instance returned can change throughout the lifetime of the application.
      # This means it is not advisable to cache it.
      #
      # The tracer can be configured through {.configure},
      # through {Datadog::Configuration::Settings::DSL::Tracer} options.
      #
      # @deprecated Use public API methods available in {Datadog::Tracing} instead.
      # @return [Datadog::Tracer] the active tracer
      # @!attribute [r] tracer
      # @public_api
      def tracer
        components.tracer
      end

      # The tracer's internal logger instance.
      # All tracing log output is handled by this object.
      #
      # The logger can be configured through {.configure},
      # through {Datadog::Configuration::Settings::DSL::Logger} options.
      #
      # @!attribute [r] logger
      # @public_api
      def logger
        Datadog.logger
      end

      # Current tracer configuration.
      #
      # To modify the configuration, use {.configure}.
      #
      # @return [Datadog::Configuration::Settings]
      # @!attribute [r] configuration
      # @public_api
      def configuration
        Datadog.configuration
      end

      # Apply configuration changes to `Datadog::Tracing`. An example of a {.configure} call:
      # ```
      # Datadog::Tracing.configure do |c|
      #   c.sampling.default_rate = 1.0
      #   c.use :aws
      #   c.use :rails
      #   c.use :sidekiq
      #   # c.diagnostics.debug = true # Enables debug output
      # end
      # ```
      #
      # Because many configuration changes require restarting internal components,
      # invoking {.configure} is the only safe way to change `ddtrace` configuration.
      #
      # Successive calls to {.configure} maintain the previous configuration values:
      # configuration is additive between {.configure} calls.
      #
      # The yielded configuration `c` comes pre-populated from environment variables, if
      # any are applicable.
      #
      # See {Datadog::Configuration::Settings} for all available options, defaults, and
      # available environment variables for configuration.
      #
      # @yieldparam [Datadog::Configuration::Settings] c the mutable configuration object
      # @return [void]
      # @public_api
      def configure(&block)
        Datadog.configure(&block)
      end

      # Apply configuration changes only to a specific Ruby object. An example of a {.configure_onto} call:
      #
      # ```
      # Datadog::Tracing.configure do |c|
      #   c.use :http, service_name: 'http-requests'
      # end
      #
      # client = Net::HTTP.new(host, port)
      # Datadog::Tracing.configure_onto(client, service_name: 'api-requests', split_by_domain: true)
      # ```
      #
      # This example will configure the `client` object with custom options
      # `service_name: 'api-requests', split_by_domain: true`, while other `Net::HTTP`
      # in the same application will use the `service_name: 'http-requests'` configuration
      # provided to the `Datadog::Tracing.configure` call block.
      #
      # {.configure_onto} is used to separate cases where spans generated by certain objects
      # require exceptional options.
      #
      # The configuration keyword arguments provided refer to the options in the integration
      # respective to the `target` object in question: for example, for
      # `Datadog::Tracing.configure_onto(redis_client, **opts)`, `opts` can be any of the options in
      # the Redis {Datadog::Contrib::Redis::Configuration::Settings} class.
      #
      # @param [Object] target the object to receive configuration options
      # @param [Hash] opts keyword arguments respective to the integration this object belongs to
      # @public_api
      def configure_onto(target, **opts)
        Datadog::Configuration::PinSetup.new(target, **opts).call
      end

      # (see Datadog::Tracer#active_trace)
      # @public_api
      def active_trace
        current_tracer = tracer
        return unless current_tracer

        current_tracer.active_trace
      end

      # (see Datadog::Tracer#active_span)
      # @public_api
      def active_span
        current_tracer = tracer
        return unless current_tracer

        current_tracer.active_span
      end

      # (see Datadog::TraceSegment#keep!)
      # If no trace is active, no action is taken.
      # @public_api
      def keep!
        trace = active_trace
        active_trace.keep! if trace
      end

      # (see Datadog::TraceSegment#reject!)
      # If no trace is active, no action is taken.
      # @public_api
      def reject!
        trace = active_trace
        active_trace.reject! if trace
      end

      # (see Datadog::Tracer#active_correlation)
      # @public_api
      def correlation
        current_tracer = tracer
        return unless current_tracer

        current_tracer.active_correlation
      end

      # Textual representation of {.correlation}, which can be
      # added to individual log lines in order to correlate them with the active
      # trace.
      #
      # Example:
      #
      # ```
      # MyLogger.log("#{Datadog::Tracing.log_correlation}] My message")
      # # dd.env=prod dd.service=auth dd.version=13.8 dd.trace_id=5458478252992251 dd.span_id=7117552347370098 My message
      # ```
      #
      # @return [String] correlation information
      # @public_api
      def log_correlation
        correlation.to_log_format
      end

      # Gracefully shuts down the tracer.
      #
      # The public tracing API will still respond to method calls as usual
      # but might not internally perform the expected internal work after shutdown.
      #
      # This avoids errors being raised across the host application
      # during shutdown while allowing for the graceful decommission of resources.
      #
      # {.shutdown!} cannot be reversed.
      # @public_api
      def shutdown!
        current_tracer = tracer
        return unless current_tracer

        current_tracer.shutdown!
      end

      # The global integration registry.
      #
      # This registry holds a reference to all integrations available
      # to the tracer.
      #
      # Integrations registered in the {.registry} can be activated as follows:
      #
      # ```
      # Datadog::Tracing.configure do |c|
      #   c.use :my_registered_integration, **my_options
      # end
      # ```
      #
      # New integrations can be registered by implementing the {Datadog::Contrib::Integration} interface.
      #
      # @return [Datadog::Contrib::Registry]
      # @!attribute [r] registry
      # @public_api
      def registry
        Datadog::Contrib::REGISTRY
      end

      # (see Datadog::Pipeline.before_flush)
      def before_flush(*processors, &processor_block)
        Datadog::Pipeline.before_flush(*processors, &processor_block)
      end

      # Is the tracer collecting telemetry data in this process?
      # @return [Boolean] `true` if the tracer is collecting data in this process, otherwise `false`.
      def enabled?
        current_tracer = tracer
        return false unless current_tracer

        current_tracer.enabled
      end

      private

      # DEV: components hosts both tracing and profiling inner objects today
      def components
        Datadog.send(:components)
      end
    end
  end
end
